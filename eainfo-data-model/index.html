
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../data-lineage-plan/">
      
      
        <link rel="next" href="../schema_parser_testing/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>EAINFO Data Model - Refined Design - Catalog</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#eainfo-data-model-refined-design" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Catalog" class="md-header__button md-logo" aria-label="Catalog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Catalog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              EAINFO Data Model - Refined Design
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Catalog" class="md-nav__button md-logo" aria-label="Catalog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Catalog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../data-lineage-plan/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Data Schema &amp; Lineage Support Enhancement Plan
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    EAINFO Data Model - Refined Design
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    EAINFO Data Model - Refined Design
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        Overview
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#design-goals" class="md-nav__link">
    <span class="md-ellipsis">
      
        Design Goals
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-model" class="md-nav__link">
    <span class="md-ellipsis">
      
        Data Model
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Data Model">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#using-pydantic-for-validation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Using Pydantic for Validation
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#xml-parser-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      
        XML Parser Implementation
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#integration-with-catalog-project" class="md-nav__link">
    <span class="md-ellipsis">
      
        Integration with Catalog Project
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Integration with Catalog Project">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#database-schema-extension" class="md-nav__link">
    <span class="md-ellipsis">
      
        Database Schema Extension
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#database-operations-dbpy-extension" class="md-nav__link">
    <span class="md-ellipsis">
      
        Database Operations (db.py extension)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#usage-examples" class="md-nav__link">
    <span class="md-ellipsis">
      
        Usage Examples
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Usage Examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basic-parsing" class="md-nav__link">
    <span class="md-ellipsis">
      
        Basic Parsing
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#working-with-enumerated-values" class="md-nav__link">
    <span class="md-ellipsis">
      
        Working with Enumerated Values
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#database-integration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Database Integration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#export-to-json" class="md-nav__link">
    <span class="md-ellipsis">
      
        Export to JSON
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-strategy" class="md-nav__link">
    <span class="md-ellipsis">
      
        Testing Strategy
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Testing Strategy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    <span class="md-ellipsis">
      
        Unit Tests
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performance-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      
        Performance Considerations
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cli-integration" class="md-nav__link">
    <span class="md-ellipsis">
      
        CLI Integration
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#api-endpoints" class="md-nav__link">
    <span class="md-ellipsis">
      
        API Endpoints
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#future-enhancements" class="md-nav__link">
    <span class="md-ellipsis">
      
        Future Enhancements
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    <span class="md-ellipsis">
      
        References
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../schema_parser_testing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Schema Parser Testing
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../xml-parsing-comparison/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    XML Parsing Comparison: ElementTree vs BeautifulSoup
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Blog
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Blog
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../blog/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Blog
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Archive
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Incoming
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Incoming
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../incoming/implementation-summary/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Data Librarian Implementation Summary
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../incoming/query-enhancements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Query Enhancement Design: Data Librarian Capabilities
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../incoming/quick-reference/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Data Librarian Quick Reference
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../incoming/solidjs-chatbot-frontend-summary/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    SolidJS Chatbot Frontend Implementation Summary
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        Overview
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#design-goals" class="md-nav__link">
    <span class="md-ellipsis">
      
        Design Goals
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-model" class="md-nav__link">
    <span class="md-ellipsis">
      
        Data Model
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Data Model">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#using-pydantic-for-validation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Using Pydantic for Validation
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#xml-parser-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      
        XML Parser Implementation
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#integration-with-catalog-project" class="md-nav__link">
    <span class="md-ellipsis">
      
        Integration with Catalog Project
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Integration with Catalog Project">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#database-schema-extension" class="md-nav__link">
    <span class="md-ellipsis">
      
        Database Schema Extension
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#database-operations-dbpy-extension" class="md-nav__link">
    <span class="md-ellipsis">
      
        Database Operations (db.py extension)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#usage-examples" class="md-nav__link">
    <span class="md-ellipsis">
      
        Usage Examples
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Usage Examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basic-parsing" class="md-nav__link">
    <span class="md-ellipsis">
      
        Basic Parsing
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#working-with-enumerated-values" class="md-nav__link">
    <span class="md-ellipsis">
      
        Working with Enumerated Values
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#database-integration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Database Integration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#export-to-json" class="md-nav__link">
    <span class="md-ellipsis">
      
        Export to JSON
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-strategy" class="md-nav__link">
    <span class="md-ellipsis">
      
        Testing Strategy
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Testing Strategy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    <span class="md-ellipsis">
      
        Unit Tests
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performance-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      
        Performance Considerations
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cli-integration" class="md-nav__link">
    <span class="md-ellipsis">
      
        CLI Integration
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#api-endpoints" class="md-nav__link">
    <span class="md-ellipsis">
      
        API Endpoints
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#future-enhancements" class="md-nav__link">
    <span class="md-ellipsis">
      
        Future Enhancements
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    <span class="md-ellipsis">
      
        References
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="eainfo-data-model-refined-design">EAINFO Data Model - Refined Design</h1>
<h2 id="overview">Overview</h2>
<p>This document presents a refined Python data model for representing FGDC metadata's <code>&lt;eainfo&gt;</code> (Entity and Attribute Information) section. The model is based on analysis of the <code>scratch.xml</code> file and designed for integration with the Catalog project.</p>
<h2 id="design-goals">Design Goals</h2>
<ol>
<li><strong>Type Safety</strong>: Leverage Python type hints and Pydantic validation</li>
<li><strong>Flexibility</strong>: Support all FGDC domain value types (udom, edom, codesetd, rdom)</li>
<li><strong>Extensibility</strong>: Easy to add new fields or domain types</li>
<li><strong>Integration</strong>: Compatible with existing Catalog schema and database structure</li>
<li><strong>Performance</strong>: Efficient parsing and serialization for large metadata files</li>
<li><strong>Developer Experience</strong>: Clear structure with helpful methods and documentation</li>
</ol>
<h2 id="data-model">Data Model</h2>
<h3 id="using-pydantic-for-validation">Using Pydantic for Validation</h3>
<pre><code class="language-python">from pydantic import BaseModel, Field, field_validator, model_validator
from typing import Optional, List, Union, Literal
from enum import Enum
from datetime import datetime


class DomainType(str, Enum):
    &quot;&quot;&quot;Types of attribute domain values in FGDC metadata&quot;&quot;&quot;
    UNREPRESENTABLE = &quot;unrepresentable&quot;  # udom - free text description
    ENUMERATED = &quot;enumerated&quot;            # edom - specific allowed values
    CODESET = &quot;codeset&quot;                  # codesetd - external reference
    RANGE = &quot;range&quot;                      # rdom - numeric range


class EntityType(BaseModel):
    &quot;&quot;&quot;Entity type information describing the feature class or table

    Corresponds to FGDC &lt;enttyp&gt; element
    &quot;&quot;&quot;
    label: str = Field(..., description=&quot;Entity Type Label (enttypl) - name of the feature class/table&quot;)
    definition: Optional[str] = Field(None, description=&quot;Entity Type Definition (enttypd)&quot;)
    definition_source: Optional[str] = Field(None, description=&quot;Entity Type Definition Source (enttypds)&quot;)

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;label&quot;: &quot;S_USA.Activity_BrushDisposal&quot;,
                &quot;definition&quot;: &quot;A collection of geographic features with the same geometry type&quot;,
                &quot;definition_source&quot;: &quot;http://support.esri.com/en/knowledgebase/GISDictionary/term/feature%20class&quot;
            }
        }


class UnrepresentableDomain(BaseModel):
    &quot;&quot;&quot;Free-text domain description for attributes without specific constraints

    Corresponds to FGDC &lt;udom&gt; element
    Used when values don't fit enumerated/range/codeset patterns
    &quot;&quot;&quot;
    type: Literal[DomainType.UNREPRESENTABLE] = DomainType.UNREPRESENTABLE
    description: str = Field(..., min_length=1, description=&quot;Free-text description of valid values&quot;)

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;type&quot;: &quot;unrepresentable&quot;,
                &quot;description&quot;: &quot;Sequential unique whole numbers that are automatically generated.&quot;
            }
        }


class EnumeratedDomain(BaseModel):
    &quot;&quot;&quot;Enumerated domain with specific allowed values

    Corresponds to FGDC &lt;edom&gt; element
    Used for fields with discrete, predefined values (e.g., status codes, categories)
    &quot;&quot;&quot;
    type: Literal[DomainType.ENUMERATED] = DomainType.ENUMERATED
    value: str = Field(..., description=&quot;Enumerated Domain Value (edomv)&quot;)
    value_definition: str = Field(..., min_length=1, description=&quot;Enumerated Domain Value Definition (edomvd)&quot;)
    value_definition_source: Optional[str] = Field(None, description=&quot;Enumerated Domain Value Definition Source (edomvds)&quot;)

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;type&quot;: &quot;enumerated&quot;,
                &quot;value&quot;: &quot;1111&quot;,
                &quot;value_definition&quot;: &quot;Broadcast Burning - Covers a majority of the unit&quot;,
                &quot;value_definition_source&quot;: &quot;FACTS User Guide, Appendix B: Activity Codes&quot;
            }
        }


class CodesetDomain(BaseModel):
    &quot;&quot;&quot;Reference to external codeset or controlled vocabulary

    Corresponds to FGDC &lt;codesetd&gt; element
    Used when values are defined in external standards (e.g., ISO codes, FIPS codes)
    &quot;&quot;&quot;
    type: Literal[DomainType.CODESET] = DomainType.CODESET
    codeset_name: str = Field(..., min_length=1, description=&quot;Name of the codeset (codesetn)&quot;)
    codeset_source: str = Field(..., description=&quot;URL or reference to codeset documentation (codesets)&quot;)

    @field_validator('codeset_source')
    @classmethod
    def validate_source(cls, v: str) -&gt; str:
        &quot;&quot;&quot;Ensure source is provided and non-empty&quot;&quot;&quot;
        if not v or not v.strip():
            raise ValueError(&quot;Codeset source must be provided&quot;)
        return v.strip()

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;type&quot;: &quot;codeset&quot;,
                &quot;codeset_name&quot;: &quot;List of U.S. State Abbreviations&quot;,
                &quot;codeset_source&quot;: &quot;http://www.census.gov/geo/reference/ansi_statetables.html&quot;
            }
        }


class RangeDomain(BaseModel):
    &quot;&quot;&quot;Numeric range domain for continuous values

    Corresponds to FGDC &lt;rdom&gt; element
    Used for numeric fields with min/max constraints
    &quot;&quot;&quot;
    type: Literal[DomainType.RANGE] = DomainType.RANGE
    min_value: Optional[float] = Field(None, description=&quot;Minimum value (rdommin)&quot;)
    max_value: Optional[float] = Field(None, description=&quot;Maximum value (rdommax)&quot;)
    units: Optional[str] = Field(None, description=&quot;Units of measurement (attrunit)&quot;)

    @model_validator(mode='after')
    def validate_range(self):
        &quot;&quot;&quot;Ensure min &lt;= max if both provided&quot;&quot;&quot;
        if (self.min_value is not None and
            self.max_value is not None and
            self.min_value &gt; self.max_value):
            raise ValueError(f&quot;min_value ({self.min_value}) cannot be greater than max_value ({self.max_value})&quot;)
        return self

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;type&quot;: &quot;range&quot;,
                &quot;min_value&quot;: 0.0,
                &quot;max_value&quot;: 100.0,
                &quot;units&quot;: &quot;percent&quot;
            }
        }


# Union type for all possible domain value types
AttributeDomainValue = Union[
    UnrepresentableDomain,
    EnumeratedDomain,
    CodesetDomain,
    RangeDomain
]


class Attribute(BaseModel):
    &quot;&quot;&quot;Individual attribute/field definition

    Corresponds to FGDC &lt;attr&gt; element
    Describes a single column in a feature class or table
    &quot;&quot;&quot;
    label: str = Field(..., min_length=1, description=&quot;Attribute Label (attrlabl) - column name&quot;)
    definition: str = Field(..., min_length=1, description=&quot;Attribute Definition (attrdef)&quot;)
    definition_source: Optional[str] = Field(None, description=&quot;Attribute Definition Source (attrdefs)&quot;)
    domain_values: List[AttributeDomainValue] = Field(
        default_factory=list,
        description=&quot;List of domain value specifications (attrdomv) - can have multiple&quot;
    )

    @property
    def has_enumerated_values(self) -&gt; bool:
        &quot;&quot;&quot;Check if attribute has enumerated domain values&quot;&quot;&quot;
        return any(isinstance(dv, EnumeratedDomain) for dv in self.domain_values)

    @property
    def enumerated_values(self) -&gt; List[EnumeratedDomain]:
        &quot;&quot;&quot;Get all enumerated domain values&quot;&quot;&quot;
        return [dv for dv in self.domain_values if isinstance(dv, EnumeratedDomain)]

    @property
    def allowed_values(self) -&gt; Optional[List[str]]:
        &quot;&quot;&quot;Get list of allowed values if enumerated, None otherwise&quot;&quot;&quot;
        if self.has_enumerated_values:
            return [ed.value for ed in self.enumerated_values]
        return None

    def get_domain_by_type(self, domain_type: DomainType) -&gt; List[AttributeDomainValue]:
        &quot;&quot;&quot;Get domain values filtered by type&quot;&quot;&quot;
        return [dv for dv in self.domain_values if dv.type == domain_type]

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;label&quot;: &quot;ACTIVITY_CODE&quot;,
                &quot;definition&quot;: &quot;Activity code from FACTS system&quot;,
                &quot;definition_source&quot;: &quot;U.S. Forest Service&quot;,
                &quot;domain_values&quot;: [
                    {
                        &quot;type&quot;: &quot;enumerated&quot;,
                        &quot;value&quot;: &quot;1111&quot;,
                        &quot;value_definition&quot;: &quot;Broadcast Burning&quot;,
                        &quot;value_definition_source&quot;: &quot;FACTS User Guide&quot;
                    }
                ]
            }
        }


class DetailedEntityInfo(BaseModel):
    &quot;&quot;&quot;Detailed entity and attribute information

    Corresponds to FGDC &lt;detailed&gt; element
    Contains entity type and all attribute definitions
    &quot;&quot;&quot;
    entity_type: EntityType = Field(..., description=&quot;Entity type information&quot;)
    attributes: List[Attribute] = Field(
        default_factory=list,
        description=&quot;List of attribute definitions&quot;
    )

    @property
    def attribute_count(self) -&gt; int:
        &quot;&quot;&quot;Get total number of attributes&quot;&quot;&quot;
        return len(self.attributes)

    @property
    def attribute_labels(self) -&gt; List[str]:
        &quot;&quot;&quot;Get list of all attribute labels (column names)&quot;&quot;&quot;
        return [attr.label for attr in self.attributes]

    def get_attribute(self, label: str) -&gt; Optional[Attribute]:
        &quot;&quot;&quot;Get attribute by label (case-insensitive)&quot;&quot;&quot;
        label_lower = label.lower()
        for attr in self.attributes:
            if attr.label.lower() == label_lower:
                return attr
        return None

    def get_attributes_with_enumerated_domains(self) -&gt; List[Attribute]:
        &quot;&quot;&quot;Get all attributes that have enumerated domain values&quot;&quot;&quot;
        return [attr for attr in self.attributes if attr.has_enumerated_values]


class EntityAttributeInfo(BaseModel):
    &quot;&quot;&quot;Top-level eainfo structure

    Corresponds to FGDC &lt;eainfo&gt; element
    Root container for entity and attribute information
    &quot;&quot;&quot;
    detailed: Optional[DetailedEntityInfo] = Field(
        None,
        description=&quot;Detailed entity and attribute information&quot;
    )
    overview: Optional[str] = Field(
        None,
        description=&quot;Overview description (eaover) - optional general description&quot;
    )
    citation: Optional[str] = Field(
        None,
        description=&quot;Entity and attribute detail citation (eadetcit) - optional reference&quot;
    )

    # Metadata about the parsing/creation
    parsed_at: Optional[datetime] = Field(
        None,
        description=&quot;Timestamp when this metadata was parsed&quot;
    )
    source_file: Optional[str] = Field(
        None,
        description=&quot;Source XML file path&quot;
    )

    @property
    def has_detailed_info(self) -&gt; bool:
        &quot;&quot;&quot;Check if detailed information is available&quot;&quot;&quot;
        return self.detailed is not None

    @property
    def total_attributes(self) -&gt; int:
        &quot;&quot;&quot;Get total number of attributes across all entities&quot;&quot;&quot;
        if not self.has_detailed_info:
            return 0
        return self.detailed.attribute_count

    def to_schema_dict(self) -&gt; dict:
        &quot;&quot;&quot;Convert to simplified schema dictionary for database storage&quot;&quot;&quot;
        if not self.has_detailed_info:
            return {}

        return {
            &quot;entity_label&quot;: self.detailed.entity_type.label,
            &quot;entity_definition&quot;: self.detailed.entity_type.definition,
            &quot;attributes&quot;: [
                {
                    &quot;name&quot;: attr.label,
                    &quot;definition&quot;: attr.definition,
                    &quot;source&quot;: attr.definition_source,
                    &quot;domain_type&quot;: attr.domain_values[0].type if attr.domain_values else None,
                    &quot;allowed_values&quot;: attr.allowed_values
                }
                for attr in self.detailed.attributes
            ]
        }

    class Config:
        json_schema_extra = {
            &quot;example&quot;: {
                &quot;detailed&quot;: {
                    &quot;entity_type&quot;: {
                        &quot;label&quot;: &quot;S_USA.Activity_BrushDisposal&quot;,
                        &quot;definition&quot;: &quot;Feature class for brush disposal activities&quot;
                    },
                    &quot;attributes&quot;: [
                        {
                            &quot;label&quot;: &quot;OBJECTID&quot;,
                            &quot;definition&quot;: &quot;Internal feature number&quot;,
                            &quot;definition_source&quot;: &quot;Esri&quot;
                        }
                    ]
                },
                &quot;parsed_at&quot;: &quot;2025-11-04T10:30:00Z&quot;,
                &quot;source_file&quot;: &quot;scratch.xml&quot;
            }
        }
</code></pre>
<h2 id="xml-parser-implementation">XML Parser Implementation</h2>
<pre><code class="language-python">from xml.etree import ElementTree as ET
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class EAInfoParser:
    &quot;&quot;&quot;Parser for FGDC Entity and Attribute Information (eainfo) sections&quot;&quot;&quot;

    @staticmethod
    def parse_domain_value(domv_elem: ET.Element) -&gt; Optional[AttributeDomainValue]:
        &quot;&quot;&quot;Parse a single attrdomv element into appropriate domain type&quot;&quot;&quot;
        try:
            # Check for unrepresentable domain (udom)
            if (udom_elem := domv_elem.find('udom')) is not None:
                text = udom_elem.text or ''
                if text.strip():
                    return UnrepresentableDomain(description=text.strip())

            # Check for enumerated domain (edom)
            elif (edom_elem := domv_elem.find('edom')) is not None:
                value = edom_elem.findtext('edomv', '').strip()
                definition = edom_elem.findtext('edomvd', '').strip()
                if value and definition:
                    return EnumeratedDomain(
                        value=value,
                        value_definition=definition,
                        value_definition_source=edom_elem.findtext('edomvds')
                    )

            # Check for codeset domain (codesetd)
            elif (codesetd_elem := domv_elem.find('codesetd')) is not None:
                name = codesetd_elem.findtext('codesetn', '').strip()
                source = codesetd_elem.findtext('codesets', '').strip()
                if name and source:
                    return CodesetDomain(
                        codeset_name=name,
                        codeset_source=source
                    )

            # Check for range domain (rdom)
            elif (rdom_elem := domv_elem.find('rdom')) is not None:
                min_val = rdom_elem.findtext('rdommin')
                max_val = rdom_elem.findtext('rdommax')
                units = rdom_elem.findtext('attrunit')

                return RangeDomain(
                    min_value=float(min_val) if min_val else None,
                    max_value=float(max_val) if max_val else None,
                    units=units
                )

        except Exception as e:
            logger.warning(f&quot;Failed to parse domain value: {e}&quot;)
            return None

        return None

    @staticmethod
    def parse_attribute(attr_elem: ET.Element) -&gt; Optional[Attribute]:
        &quot;&quot;&quot;Parse a single attr element into Attribute object&quot;&quot;&quot;
        try:
            label = attr_elem.findtext('attrlabl', '').strip()
            definition = attr_elem.findtext('attrdef', '').strip()

            if not label or not definition:
                logger.warning(f&quot;Skipping attribute with missing label or definition&quot;)
                return None

            # Parse all domain values
            domain_values = []
            for domv_elem in attr_elem.findall('attrdomv'):
                domain_val = EAInfoParser.parse_domain_value(domv_elem)
                if domain_val:
                    domain_values.append(domain_val)

            return Attribute(
                label=label,
                definition=definition,
                definition_source=attr_elem.findtext('attrdefs'),
                domain_values=domain_values
            )

        except Exception as e:
            logger.error(f&quot;Failed to parse attribute: {e}&quot;)
            return None

    @staticmethod
    def parse_entity_type(enttyp_elem: ET.Element) -&gt; Optional[EntityType]:
        &quot;&quot;&quot;Parse enttyp element into EntityType object&quot;&quot;&quot;
        try:
            label = enttyp_elem.findtext('enttypl', '').strip()
            if not label:
                logger.warning(&quot;Entity type missing label&quot;)
                return None

            return EntityType(
                label=label,
                definition=enttyp_elem.findtext('enttypd'),
                definition_source=enttyp_elem.findtext('enttypds')
            )

        except Exception as e:
            logger.error(f&quot;Failed to parse entity type: {e}&quot;)
            return None

    @staticmethod
    def parse_detailed(detailed_elem: ET.Element) -&gt; Optional[DetailedEntityInfo]:
        &quot;&quot;&quot;Parse detailed element into DetailedEntityInfo object&quot;&quot;&quot;
        try:
            # Parse entity type
            enttyp_elem = detailed_elem.find('enttyp')
            if enttyp_elem is None:
                logger.warning(&quot;No entity type found in detailed section&quot;)
                return None

            entity_type = EAInfoParser.parse_entity_type(enttyp_elem)
            if not entity_type:
                return None

            # Parse all attributes
            attributes = []
            for attr_elem in detailed_elem.findall('attr'):
                attr = EAInfoParser.parse_attribute(attr_elem)
                if attr:
                    attributes.append(attr)

            logger.info(f&quot;Parsed {len(attributes)} attributes for entity {entity_type.label}&quot;)

            return DetailedEntityInfo(
                entity_type=entity_type,
                attributes=attributes
            )

        except Exception as e:
            logger.error(f&quot;Failed to parse detailed section: {e}&quot;)
            return None

    @staticmethod
    def parse_eainfo(eainfo_elem: ET.Element, source_file: Optional[str] = None) -&gt; EntityAttributeInfo:
        &quot;&quot;&quot;Parse eainfo element into EntityAttributeInfo object

        Args:
            eainfo_elem: XML element containing eainfo data
            source_file: Optional path to source XML file

        Returns:
            EntityAttributeInfo object
        &quot;&quot;&quot;
        try:
            detailed = None
            detailed_elem = eainfo_elem.find('detailed')
            if detailed_elem is not None:
                detailed = EAInfoParser.parse_detailed(detailed_elem)

            # Parse optional overview and citation
            overview = eainfo_elem.findtext('overview/eaover')
            citation = eainfo_elem.findtext('overview/eadetcit')

            return EntityAttributeInfo(
                detailed=detailed,
                overview=overview,
                citation=citation,
                parsed_at=datetime.now(),
                source_file=source_file
            )

        except Exception as e:
            logger.error(f&quot;Failed to parse eainfo: {e}&quot;)
            return EntityAttributeInfo(source_file=source_file)

    @staticmethod
    def parse_xml_file(xml_file_path: str) -&gt; EntityAttributeInfo:
        &quot;&quot;&quot;Parse XML file and extract eainfo section

        Args:
            xml_file_path: Path to FGDC XML metadata file

        Returns:
            EntityAttributeInfo object

        Example:
            &gt;&gt;&gt; parser = EAInfoParser()
            &gt;&gt;&gt; eainfo = parser.parse_xml_file('scratch.xml')
            &gt;&gt;&gt; print(f&quot;Found {eainfo.total_attributes} attributes&quot;)
        &quot;&quot;&quot;
        file_path = Path(xml_file_path)
        if not file_path.exists():
            logger.error(f&quot;File not found: {xml_file_path}&quot;)
            return EntityAttributeInfo(source_file=xml_file_path)

        try:
            tree = ET.parse(xml_file_path)
            eainfo_elem = tree.find('.//eainfo')

            if eainfo_elem is None:
                logger.warning(f&quot;No eainfo element found in {xml_file_path}&quot;)
                return EntityAttributeInfo(source_file=xml_file_path)

            return EAInfoParser.parse_eainfo(eainfo_elem, source_file=xml_file_path)

        except ET.ParseError as e:
            logger.error(f&quot;XML parsing error in {xml_file_path}: {e}&quot;)
            return EntityAttributeInfo(source_file=xml_file_path)
        except Exception as e:
            logger.error(f&quot;Unexpected error parsing {xml_file_path}: {e}&quot;)
            return EntityAttributeInfo(source_file=xml_file_path)
</code></pre>
<h2 id="integration-with-catalog-project">Integration with Catalog Project</h2>
<h3 id="database-schema-extension">Database Schema Extension</h3>
<p>Add to <code>sql/schema.sql</code>:</p>
<pre><code class="language-sql">-- Table to store entity attribute information
CREATE TABLE IF NOT EXISTS entity_attribute_info (
    id SERIAL PRIMARY KEY,
    dataset_id INTEGER REFERENCES datasets(id) ON DELETE CASCADE,
    entity_label VARCHAR(255) NOT NULL,
    entity_definition TEXT,
    entity_definition_source TEXT,
    parsed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    source_file TEXT,
    UNIQUE(dataset_id, entity_label)
);

CREATE INDEX idx_eainfo_dataset ON entity_attribute_info(dataset_id);

-- Table to store individual attributes
CREATE TABLE IF NOT EXISTS attributes (
    id SERIAL PRIMARY KEY,
    eainfo_id INTEGER REFERENCES entity_attribute_info(id) ON DELETE CASCADE,
    label VARCHAR(255) NOT NULL,
    definition TEXT NOT NULL,
    definition_source TEXT,
    position INTEGER,  -- Order in the table
    UNIQUE(eainfo_id, label)
);

CREATE INDEX idx_attributes_eainfo ON attributes(eainfo_id);

-- Table to store domain values (normalized)
CREATE TABLE IF NOT EXISTS attribute_domains (
    id SERIAL PRIMARY KEY,
    attribute_id INTEGER REFERENCES attributes(id) ON DELETE CASCADE,
    domain_type VARCHAR(50) NOT NULL,  -- 'unrepresentable', 'enumerated', 'codeset', 'range'

    -- Unrepresentable domain fields
    description TEXT,

    -- Enumerated domain fields
    enum_value VARCHAR(255),
    enum_value_definition TEXT,
    enum_value_definition_source TEXT,

    -- Codeset domain fields
    codeset_name VARCHAR(255),
    codeset_source TEXT,

    -- Range domain fields
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    units VARCHAR(100),

    position INTEGER  -- Order in domain list
);

CREATE INDEX idx_domains_attribute ON attribute_domains(attribute_id);
CREATE INDEX idx_domains_type ON attribute_domains(domain_type);

-- Create view for easy querying
CREATE OR REPLACE VIEW v_attribute_summary AS
SELECT
    eai.dataset_id,
    eai.entity_label,
    a.label as attribute_label,
    a.definition as attribute_definition,
    COUNT(DISTINCT ad.id) as domain_count,
    STRING_AGG(DISTINCT ad.domain_type, ', ') as domain_types,
    COUNT(CASE WHEN ad.domain_type = 'enumerated' THEN 1 END) as enum_value_count
FROM entity_attribute_info eai
JOIN attributes a ON a.eainfo_id = eai.id
LEFT JOIN attribute_domains ad ON ad.attribute_id = a.id
GROUP BY eai.dataset_id, eai.entity_label, a.label, a.definition;
</code></pre>
<h3 id="database-operations-dbpy-extension">Database Operations (db.py extension)</h3>
<pre><code class="language-python"># Add to src/catalog/core/db.py

from typing import Optional, List
from .schema_parser import EntityAttributeInfo, Attribute, AttributeDomainValue
from .schema_parser import UnrepresentableDomain, EnumeratedDomain, CodesetDomain, RangeDomain

def store_eainfo(conn, dataset_id: int, eainfo: EntityAttributeInfo) -&gt; Optional[int]:
    &quot;&quot;&quot;Store EntityAttributeInfo in database

    Args:
        conn: Database connection
        dataset_id: ID of associated dataset
        eainfo: EntityAttributeInfo object to store

    Returns:
        ID of inserted entity_attribute_info record, or None if no detailed info
    &quot;&quot;&quot;
    if not eainfo.has_detailed_info:
        return None

    cursor = conn.cursor()

    try:
        # Insert entity info
        cursor.execute(&quot;&quot;&quot;
            INSERT INTO entity_attribute_info
            (dataset_id, entity_label, entity_definition, entity_definition_source, source_file, parsed_at)
            VALUES (%s, %s, %s, %s, %s, %s)
            ON CONFLICT (dataset_id, entity_label)
            DO UPDATE SET
                entity_definition = EXCLUDED.entity_definition,
                entity_definition_source = EXCLUDED.entity_definition_source,
                parsed_at = EXCLUDED.parsed_at
            RETURNING id
        &quot;&quot;&quot;, (
            dataset_id,
            eainfo.detailed.entity_type.label,
            eainfo.detailed.entity_type.definition,
            eainfo.detailed.entity_type.definition_source,
            eainfo.source_file,
            eainfo.parsed_at
        ))

        eainfo_id = cursor.fetchone()[0]

        # Insert attributes
        for position, attr in enumerate(eainfo.detailed.attributes):
            cursor.execute(&quot;&quot;&quot;
                INSERT INTO attributes
                (eainfo_id, label, definition, definition_source, position)
                VALUES (%s, %s, %s, %s, %s)
                ON CONFLICT (eainfo_id, label)
                DO UPDATE SET
                    definition = EXCLUDED.definition,
                    definition_source = EXCLUDED.definition_source,
                    position = EXCLUDED.position
                RETURNING id
            &quot;&quot;&quot;, (
                eainfo_id,
                attr.label,
                attr.definition,
                attr.definition_source,
                position
            ))

            attr_id = cursor.fetchone()[0]

            # Insert domain values
            for dom_pos, domain in enumerate(attr.domain_values):
                _store_domain_value(cursor, attr_id, domain, dom_pos)

        conn.commit()
        return eainfo_id

    except Exception as e:
        conn.rollback()
        raise e
    finally:
        cursor.close()


def _store_domain_value(cursor, attribute_id: int, domain: AttributeDomainValue, position: int):
    &quot;&quot;&quot;Store a single domain value&quot;&quot;&quot;
    base_values = {
        'attribute_id': attribute_id,
        'domain_type': domain.type,
        'position': position
    }

    if isinstance(domain, UnrepresentableDomain):
        cursor.execute(&quot;&quot;&quot;
            INSERT INTO attribute_domains
            (attribute_id, domain_type, description, position)
            VALUES (%(attribute_id)s, %(domain_type)s, %(description)s, %(position)s)
        &quot;&quot;&quot;, {**base_values, 'description': domain.description})

    elif isinstance(domain, EnumeratedDomain):
        cursor.execute(&quot;&quot;&quot;
            INSERT INTO attribute_domains
            (attribute_id, domain_type, enum_value, enum_value_definition,
             enum_value_definition_source, position)
            VALUES (%(attribute_id)s, %(domain_type)s, %(enum_value)s,
                    %(enum_value_definition)s, %(enum_value_definition_source)s, %(position)s)
        &quot;&quot;&quot;, {
            **base_values,
            'enum_value': domain.value,
            'enum_value_definition': domain.value_definition,
            'enum_value_definition_source': domain.value_definition_source
        })

    elif isinstance(domain, CodesetDomain):
        cursor.execute(&quot;&quot;&quot;
            INSERT INTO attribute_domains
            (attribute_id, domain_type, codeset_name, codeset_source, position)
            VALUES (%(attribute_id)s, %(domain_type)s, %(codeset_name)s, %(codeset_source)s, %(position)s)
        &quot;&quot;&quot;, {
            **base_values,
            'codeset_name': domain.codeset_name,
            'codeset_source': domain.codeset_source
        })

    elif isinstance(domain, RangeDomain):
        cursor.execute(&quot;&quot;&quot;
            INSERT INTO attribute_domains
            (attribute_id, domain_type, min_value, max_value, units, position)
            VALUES (%(attribute_id)s, %(domain_type)s, %(min_value)s, %(max_value)s, %(units)s, %(position)s)
        &quot;&quot;&quot;, {
            **base_values,
            'min_value': domain.min_value,
            'max_value': domain.max_value,
            'units': domain.units
        })


def get_eainfo_for_dataset(conn, dataset_id: int) -&gt; Optional[EntityAttributeInfo]:
    &quot;&quot;&quot;Retrieve EntityAttributeInfo from database

    Args:
        conn: Database connection
        dataset_id: ID of dataset

    Returns:
        EntityAttributeInfo object or None if not found
    &quot;&quot;&quot;
    # Implementation left as exercise - reverse of store_eainfo
    pass
</code></pre>
<h2 id="usage-examples">Usage Examples</h2>
<h3 id="basic-parsing">Basic Parsing</h3>
<pre><code class="language-python">from catalog.core.schema_parser import EAInfoParser

# Parse XML file
parser = EAInfoParser()
eainfo = parser.parse_xml_file('scratch.xml')

# Access entity information
if eainfo.has_detailed_info:
    print(f&quot;Entity: {eainfo.detailed.entity_type.label}&quot;)
    print(f&quot;Attributes: {eainfo.total_attributes}&quot;)

    # List all attributes
    for attr in eainfo.detailed.attributes:
        print(f&quot;  - {attr.label}: {attr.definition}&quot;)
</code></pre>
<h3 id="working-with-enumerated-values">Working with Enumerated Values</h3>
<pre><code class="language-python"># Get attributes with enumerated domains
enum_attrs = eainfo.detailed.get_attributes_with_enumerated_domains()

for attr in enum_attrs:
    print(f&quot;\n{attr.label} allowed values:&quot;)
    for enum_val in attr.enumerated_values:
        print(f&quot;  {enum_val.value}: {enum_val.value_definition}&quot;)
</code></pre>
<h3 id="database-integration">Database Integration</h3>
<pre><code class="language-python">from catalog.core.db import get_connection, store_eainfo
from catalog.core.schema_parser import EAInfoParser

# Parse and store
parser = EAInfoParser()
eainfo = parser.parse_xml_file('scratch.xml')

with get_connection() as conn:
    dataset_id = 123  # existing dataset ID
    eainfo_id = store_eainfo(conn, dataset_id, eainfo)
    print(f&quot;Stored eainfo with ID: {eainfo_id}&quot;)
</code></pre>
<h3 id="export-to-json">Export to JSON</h3>
<pre><code class="language-python"># Export for API responses
eainfo_dict = eainfo.model_dump(exclude_none=True)
import json
print(json.dumps(eainfo_dict, indent=2))

# Simplified schema for frontend
schema = eainfo.to_schema_dict()
print(schema)
</code></pre>
<h2 id="testing-strategy">Testing Strategy</h2>
<h3 id="unit-tests">Unit Tests</h3>
<pre><code class="language-python"># tests/test_schema_parser.py

import pytest
from catalog.core.schema_parser import (
    EntityAttributeInfo, Attribute, EnumeratedDomain,
    UnrepresentableDomain, EAInfoParser
)
from xml.etree import ElementTree as ET


def test_enumerated_domain_validation():
    &quot;&quot;&quot;Test EnumeratedDomain validation&quot;&quot;&quot;
    # Valid domain
    domain = EnumeratedDomain(
        value=&quot;1111&quot;,
        value_definition=&quot;Broadcast Burning&quot;
    )
    assert domain.value == &quot;1111&quot;

    # Invalid - empty definition should fail
    with pytest.raises(ValueError):
        EnumeratedDomain(value=&quot;1111&quot;, value_definition=&quot;&quot;)


def test_range_domain_validation():
    &quot;&quot;&quot;Test RangeDomain min/max validation&quot;&quot;&quot;
    from catalog.core.schema_parser import RangeDomain

    # Valid range
    domain = RangeDomain(min_value=0, max_value=100)
    assert domain.min_value == 0

    # Invalid - min &gt; max should fail
    with pytest.raises(ValueError):
        RangeDomain(min_value=100, max_value=0)


def test_attribute_properties():
    &quot;&quot;&quot;Test Attribute helper properties&quot;&quot;&quot;
    attr = Attribute(
        label=&quot;STATUS&quot;,
        definition=&quot;Status code&quot;,
        domain_values=[
            EnumeratedDomain(value=&quot;A&quot;, value_definition=&quot;Active&quot;),
            EnumeratedDomain(value=&quot;I&quot;, value_definition=&quot;Inactive&quot;)
        ]
    )

    assert attr.has_enumerated_values
    assert attr.allowed_values == [&quot;A&quot;, &quot;I&quot;]
    assert len(attr.enumerated_values) == 2


def test_parser_with_sample_xml():
    &quot;&quot;&quot;Test parsing actual XML&quot;&quot;&quot;
    xml_str = &quot;&quot;&quot;
    &lt;eainfo&gt;
        &lt;detailed&gt;
            &lt;enttyp&gt;
                &lt;enttypl&gt;TestEntity&lt;/enttypl&gt;
                &lt;enttypd&gt;Test definition&lt;/enttypd&gt;
            &lt;/enttyp&gt;
            &lt;attr&gt;
                &lt;attrlabl&gt;TEST_FIELD&lt;/attrlabl&gt;
                &lt;attrdef&gt;Test field definition&lt;/attrdef&gt;
                &lt;attrdefs&gt;Test Source&lt;/attrdefs&gt;
                &lt;attrdomv&gt;
                    &lt;udom&gt;Any text value&lt;/udom&gt;
                &lt;/attrdomv&gt;
            &lt;/attr&gt;
        &lt;/detailed&gt;
    &lt;/eainfo&gt;
    &quot;&quot;&quot;

    elem = ET.fromstring(xml_str)
    eainfo = EAInfoParser.parse_eainfo(elem)

    assert eainfo.has_detailed_info
    assert eainfo.detailed.entity_type.label == &quot;TestEntity&quot;
    assert len(eainfo.detailed.attributes) == 1
    assert eainfo.detailed.attributes[0].label == &quot;TEST_FIELD&quot;


def test_parse_scratch_xml():
    &quot;&quot;&quot;Integration test with actual scratch.xml file&quot;&quot;&quot;
    eainfo = EAInfoParser.parse_xml_file('scratch.xml')

    assert eainfo.has_detailed_info
    assert eainfo.total_attributes &gt; 0
    assert eainfo.source_file == 'scratch.xml'

    # Check for known attributes from USFS data
    attr = eainfo.detailed.get_attribute('OBJECTID')
    assert attr is not None
    assert 'feature number' in attr.definition.lower()
</code></pre>
<h3 id="performance-considerations">Performance Considerations</h3>
<pre><code class="language-python"># For large XML files, consider streaming parser
from lxml import etree

def parse_large_xml_streaming(xml_file_path: str):
    &quot;&quot;&quot;Memory-efficient parsing for large XML files&quot;&quot;&quot;
    context = etree.iterparse(xml_file_path, events=('end',), tag='eainfo')

    for event, elem in context:
        eainfo = EAInfoParser.parse_eainfo(elem)
        yield eainfo

        # Clear element to free memory
        elem.clear()
        while elem.getprevious() is not None:
            del elem.getparent()[0]
</code></pre>
<h2 id="cli-integration">CLI Integration</h2>
<p>Add to <code>src/catalog/cli/cli.py</code>:</p>
<pre><code class="language-python">@app.command()
def parse_schema(
    xml_file: str = typer.Argument(..., help=&quot;Path to XML metadata file&quot;),
    output: Optional[str] = typer.Option(None, help=&quot;Output JSON file path&quot;),
    store_db: bool = typer.Option(False, help=&quot;Store in database&quot;),
    dataset_id: Optional[int] = typer.Option(None, help=&quot;Dataset ID for database storage&quot;)
):
    &quot;&quot;&quot;Parse entity and attribute information from XML metadata&quot;&quot;&quot;
    from catalog.core.schema_parser import EAInfoParser
    from catalog.core.db import get_connection, store_eainfo
    import json

    parser = EAInfoParser()
    eainfo = parser.parse_xml_file(xml_file)

    if not eainfo.has_detailed_info:
        typer.echo(&quot;No entity/attribute information found in XML file&quot;, err=True)
        raise typer.Exit(1)

    typer.echo(f&quot; Parsed entity: {eainfo.detailed.entity_type.label}&quot;)
    typer.echo(f&quot; Found {eainfo.total_attributes} attributes&quot;)

    # Display enumerated attributes
    enum_attrs = eainfo.detailed.get_attributes_with_enumerated_domains()
    if enum_attrs:
        typer.echo(f&quot; {len(enum_attrs)} attributes have enumerated values&quot;)

    # Output to JSON
    if output:
        with open(output, 'w') as f:
            json.dump(eainfo.model_dump(exclude_none=True), f, indent=2, default=str)
        typer.echo(f&quot; Saved to {output}&quot;)

    # Store in database
    if store_db:
        if not dataset_id:
            typer.echo(&quot;Error: --dataset-id required when using --store-db&quot;, err=True)
            raise typer.Exit(1)

        with get_connection() as conn:
            eainfo_id = store_eainfo(conn, dataset_id, eainfo)
            typer.echo(f&quot; Stored in database with ID: {eainfo_id}&quot;)
</code></pre>
<p>Usage:</p>
<pre><code class="language-bash"># Parse and display
./run-cli.sh parse-schema scratch.xml

# Parse and save to JSON
./run-cli.sh parse-schema scratch.xml --output schema.json

# Parse and store in database
./run-cli.sh parse-schema scratch.xml --store-db --dataset-id 123
</code></pre>
<h2 id="api-endpoints">API Endpoints</h2>
<p>Add to <code>src/catalog/api/api.py</code>:</p>
<pre><code class="language-python">from fastapi import HTTPException
from catalog.core.schema_parser import EntityAttributeInfo

@app.get(&quot;/datasets/{dataset_id}/schema&quot;)
async def get_dataset_schema(dataset_id: int) -&gt; dict:
    &quot;&quot;&quot;Get entity and attribute information for a dataset&quot;&quot;&quot;
    conn = get_connection()

    try:
        eainfo = get_eainfo_for_dataset(conn, dataset_id)
        if not eainfo or not eainfo.has_detailed_info:
            raise HTTPException(status_code=404, detail=&quot;Schema not found&quot;)

        return eainfo.to_schema_dict()

    finally:
        conn.close()


@app.get(&quot;/datasets/{dataset_id}/attributes/{attribute_label}&quot;)
async def get_attribute_detail(dataset_id: int, attribute_label: str) -&gt; dict:
    &quot;&quot;&quot;Get detailed information about a specific attribute&quot;&quot;&quot;
    conn = get_connection()

    try:
        eainfo = get_eainfo_for_dataset(conn, dataset_id)
        if not eainfo or not eainfo.has_detailed_info:
            raise HTTPException(status_code=404, detail=&quot;Schema not found&quot;)

        attr = eainfo.detailed.get_attribute(attribute_label)
        if not attr:
            raise HTTPException(status_code=404, detail=&quot;Attribute not found&quot;)

        return attr.model_dump(exclude_none=True)

    finally:
        conn.close()
</code></pre>
<h2 id="future-enhancements">Future Enhancements</h2>
<ol>
<li><strong>Validation Rules</strong>: Generate data validation rules from domain constraints</li>
<li><strong>Schema Comparison</strong>: Compare schemas across different versions</li>
<li><strong>Documentation Generation</strong>: Auto-generate data dictionaries</li>
<li><strong>Search Enhancement</strong>: Index attribute definitions for better search</li>
<li><strong>Data Quality Checks</strong>: Validate actual data against domain constraints</li>
<li><strong>Visualization</strong>: Generate ER diagrams from entity relationships</li>
<li><strong>Import/Export</strong>: Support other metadata formats (ISO 19115, DCAT)</li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.fgdc.gov/standards/projects/metadata/base-metadata/v2_0698.pdf">FGDC Content Standard for Digital Geospatial Metadata</a></li>
<li><a href="https://www.usgs.gov/data-management/metadata-creation">USGS Metadata Creation Guide</a></li>
<li><a href="https://docs.pydantic.dev/">Pydantic Documentation</a></li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": [], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
    
  </body>
</html>